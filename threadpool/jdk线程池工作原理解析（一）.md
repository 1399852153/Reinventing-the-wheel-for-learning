# jdk线程池工作原理解析(一)
### 线程池介绍
在日常开发中经常会遇到使用其它线程将大量任务异步处理的场景（异步化以及提升系统的吞吐量），但在使用线程时存在着两个痛点。
1. 在java等很多主流语言中每个逻辑上的线程底层都对应着一个系统线程（不考虑虚拟线程的情况）。操作系统创建一个新线程是存在一定开销的，
   在需要执行**大量的**异步任务时，如果处理每个任务时都直接向系统申请创建一个线程来执行，并在任务执行完毕后再回收线程，则创建/销毁大量线程的开销将无法忍受。
2. 每个系统线程都会占用一定的内存空间，且系统在调度不同线程上下文切换时存在一定的cpu开销。因此在一定的硬件条件下，操作系统能同时维护的系统线程个数是比较有限的。
   在使用线程的过程中如果没有控制好流量，会很容易创建过多的线程而耗尽系统资源，令系统变得不可用。

而线程池正是为解决上述痛点而生的，其通过两个手段来解决上述痛点。
##### 池化线程资源
池化线程资源，顾名思义就是维护一个存活线程的集合（池子）。提交任务的用户程序不直接控制线程的创建和销毁，不用每次执行任务时都申请创建一个新线程，而是通过线程池间接的获得线程去处理异步任务。
线程池中的线程在执行完任务后通常也不会被系统回收掉，而是继续待在池子中用于执行其它的任务（执行堆积的待执行任务或是等待新任务）。  
**线程池通过池化线程资源，避免了系统反复创建/销毁线程的开销，大幅提高了处理大规模异步任务时的性能。**
##### 对线程资源的申请进行收口，限制系统资源的使用
如果程序都统一使用线程池来处理异步任务，那么线程池内部便可以对系统资源的使用施加一定限制。
例如用户可以指定一个线程池最大可维护的线程数量，避免耗尽系统资源。
当用户提交任务的速率过大，导致线程池中的线程数到达指定的最大值时依然无法满足需求时，线程池可以通过丢弃部分任务或限制提交任务的流量的方式来处理这一问题。  
**线程池通过对线程资源的使用进行统一收口，用户可以通过线程池的参数限制系统资源的使用，从而避免系统资源耗尽。**

### jdk线程池ThreadPoolExecutor简单介绍
前面介绍了线程池的概念，而要深入理解线程池的工作原理最好的办法便是找到一个优秀的线程池实现来加以研究。  
而自jdk1.5中引入的通用线程池框架ThreadPoolExecutor便是一个很好的学习对象。其内部实现不算复杂，却在高效实现核心功能的同时还提供了较丰富的拓展能力。
#####
下面从整体上介绍一下jdk通用线程池ThreadPoolExecutor的工作原理（基于jdk8）。
##### ThreadPoolExecutor运行时工作流程
首先ThreadPoolExecutor允许用户从两个不同维度来控制线程资源的使用，即最大核心线程数(corePoolSize)和最大线程数(maximumPoolSize)。
最大核心线程数：核心线程指的是**通常**常驻线程池的线程。常驻线程在线程池没有任务空闲时也不会被销毁，而是处于idle状态，这样在新任务到来时就能很快的进行响应。
最大线程数：和第一节中提到的一样，即线程池中所能允许的活跃线程的最大数量。
#####
在向ThreadPoolExecutor提交任务时（execute方法），会执行一系列的判断来决定任务应该如何被执行（源码在下一节中具体分析）。
1. 首先判断当前活跃的线程数是否小于指定的**最大核心线程数corePoolSize**。  
   如果为真，则说明当前线程池还未完成预热，核心线程数不饱和，创建一个新线程来执行该任务。  
   如果为假，则说明当前线程池已完成预热，进行下一步判断。
2. 尝试将当前任务放入**工作队列workQueue**（阻塞队列BlockingQueue类型），工作队列中的任务会被线程池中的活跃线程按入队顺序逐个消费。  
   如果入队成功，则说明当前工作队列未满，入队的任务将会被线程池中的某个活跃线程所消费并执行。  
   如果入队失败，则说明当前工作队列已饱和，线程池消费任务的速度可能太慢了，可能需要创建更多新线程来加速消费，进行下一步判断。
3. 判断当前活跃的线程数是否小于指定的**最大线程数maximumPoolSize**。  
   如果为真，则说明当前线程池所承载的线程数还未达到参数指定的上限，还有余量来创建新的线程加速消费，创建一个新线程来执行该任务。  
   如果为假，则说明当前线程池所承载的线程数达到了上限，但处理任务的速度依然不够快，需要触发**拒绝策略**。  
![ThreadPoolExecutor提交任务流程图.png](ThreadPoolExecutor提交任务流程图.png)
##### ThreadPoolExecutor优雅停止
线程池的优雅停止一般要能做到以下几点：
1. 线程池在中止后不能再受理新的任务
2. 线程池中止的过程中，已经提交的现存任务不能丢失（等待剩余任务执行完再关闭或者能够把剩余的任务吐出来还给用户）
3. 线程池最终关闭前，确保创建的所有工作线程都已退出，不会出现资源的泄露
#####
线程池自启动后便会有大量的工作线程在内部持续不断并发的执行提交的各种任务，而要想做到优雅停止并不是一件容易的事情。
因此ThreadPoolExecutor中最复杂的部分并不在于上文中的正常工作流程，而在于分散在各个地方但又紧密协作的，控制优雅停止的逻辑。
##### ThreadPoolExecutor的其它功能
除了正常的工作流程以及优雅停止的功能外，ThreadPoolExecutor还提供了一些比较好用的功能
1. 提供了很多protected的钩子函数方便用户继承后进行各种拓展
2. 在运行时统计了总共执行的任务数等关键指标，并提供了对应的api便于用户在运行时观察运行状态
3. 允许在线程池运行过程中动态修改关键的配置参数（比如corePoolSize等），并实时的生效。

### jdk线程池ThreadPoolExecutor源码解析(自己动手实现线程池v1版本)
如费曼所说的：What I can not create I do not understand（我不能理解我创造不了的东西）。
通过模仿jdk的ThreadPoolExecutor实现，从零开始实现一个线程池，可以迫使自己去仔细的捋清楚jdk线程池中设计的各种细节，加深理解以达到更好的学习效果。
#####
前面提到ThreadPoolExecutor的核心逻辑主要分为两部分，一是正常运行时处理提交的任务的逻辑，二是实现优雅停止的逻辑。
因此我们实现的线程池MyThreadPoolExecutor也会分为两个版本，v1版本只实现前一部分即正常运行时执行任务的逻辑，将有关线程池优雅停止的逻辑全部去除。
相比直接啃jdk最终实现的源码，v1版本的实现会更简单更易理解，让正常执行任务时的逻辑更加清洗而不会耦合太多优雅停止的逻辑。

### 总结