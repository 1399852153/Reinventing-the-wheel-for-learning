# Hashed and Hierarchical Timing Wheels: Efficient Data Structures for Implementing a Timer Facility（多层次的哈希时间轮：实现计时器功能的高效数据结构）
作者：George Varghese and Anthony Lauck

##### 
Abstract— The performance of timer algorithms is crucial to many network protocol implementations that use timers for failure recovery and rate control.  
Conventional algorithms to implement an Operating System timer module take O(n) time to start or maintain a timer, 
where n is the number of outstanding timers: this is expensive for large n.   
This paper shows that by using a circular buffer or timing wheel, it takes O(1) time to start, stop, and maintain timers within the range of the wheel.
摘要- 在很多使用计时器来实现故障恢复和速率控制的网络协议中，计时器算法的性能是非常关键的。
用于实现操作系统计时器模块的常规算法需要花费O(n)的时间复杂度用于启动或者维护一个计时器，n是待完成的计时器对象个数：对于一个很大的n值其开销是巨大的。  
本篇论文展示了通过使用一个环形缓冲器或时间轮，只需要O(1)的时间复杂度便可做到启动、停止和维护一个在当前时间轮范围内的计时器。  

#####
Two extensions for larger values of the interval are described.  
In the first, the timer interval is hashed into a slot on the timing wheel.  
In the second, a hierarchy of timing wheels with different granularities is used to span a greater range of intervals.
The performance of these two schemes and various implementation tradeoffs are discussed.
We have used one of our schemes to replace the current BSD UNIX callout and timer facilities.
Our new implementation can support thousands of outstanding timers without much overhead.
Our timer schemes have also been implemented in other operating systems and network protocol packages.
这里描述了对于支持更大范围区间的两方面拓展。  
首先，计时器的区间被哈希映射到时间轮的一个插槽中。其次，一个具有不同粒度的、具有层次性的时间轮能够拓展支持更大的区间。  
这里讨论了两种方案的性能以及不同实现方式的取舍。  
我们已经使用一种我们的方案来替换当前BSD-UNIX操作系统的UNIX调用和计时器设施。  
我们的新实现可以支持数以千计的待完成的计时器而没有额外的开销。  
我们的计时器实现方案也已经在其它的操作系统和网络协议包中被实现了。  

### I. INTRODUCTION（介绍）
#####
In a centralized or distributed system, we need timers for the following.
在一个中心化的或者分布式的系统中，我们需要以下所展示的计时器。  

#####
Failure Recovery: Several kinds of failures cannot be detected asynchronously.   
Some can be detected by periodic checking (e.g., memory corruption) and such timers always expire.   
Other failures can only be inferred by the lack of some positive action (e.g., message acknowledgment) within a specified period.   
If failures are infrequent, these timers rarely expire.  
故障恢复：少数几种无法被异步检查的故障。其中一些可以被周期性的检查所发现（例如内存损坏memory corruption），并且这些计时器总是会过期。  
其它故障的检测只能通过在一个指定的周期内缺乏某些积极的动作（比如消息确认）来推测。如果故障很少发生，则这些计时器也几乎不会过期

#####
Algorithms in Which the Notion of Time or Relative Time is Integral: 
Examples include algorithms that control the rate of production of some entity (process control, rate-based flow control in communications), 
scheduling algorithms, and algorithms to control packet lifetimes in computer networks.
These timers almost always expire.
关于时间或相对时间的概念是属于积分算法的：
例如包括一些实体生产速率的控制算法（过程控制，通信中基于速度的流量控制），调度算法以及控制计算机网络中数据包存活时间的算法。  
而这些计时器几乎总是会过期的。

#####
The performance of algorithms to implement a timer module becomes an issue when any of the following are true.
* The algorithm is implemented by a processor that is interrupted each time a hardware clock ticks, and the interrupt overhead is substantial.
* Fine granularity timers are required.
* The average number of outstanding timers is large.
当以下任意一项为真时，实现计时器模块的算法就会有性能问题
* 该算法由一个处理器实现，该处理器在每次硬件时钟tick时便被中断，其中断处理的开销是巨大的
* 需要非常细粒度的计时器
* 待完成的计时器平均数量非常大

#####
If the hardware clock interrupts the host every tick, and the interval between ticks is in the order of microseconds, 
then the interrupt overhead is substantial. 
Most host operating systems offer timers of coarse (milliseconds or seconds) granularity.
Alternately, in some systems finer granularity timers reside in special-purpose hardware. 
In either case, the performance of the timer algorithms will be an issue as they determine the latency incurred in starting 
or stopping a timer and the number of timers that can be simultaneously outstanding.
如果每一次硬件时钟tick都会中断主机，且每次tick的间隔在微秒级别，那么中断的开销就会是巨大的。  
大多数的主机操作系统提供的计时器通常是在毫秒或者秒级粒度的。或者，在一些系统中更细粒度的计时器则由专门的硬件实现。  
在任一一种情况下，计时器算法的性能都将是一个问题，因为他们决定了启动或者停止一个计时器的延迟以及可以同一时刻下可维持的待完成计时器的数量。

#####
As an example, consider communications between members of a distributed system. 
Since messages can be lost in the underlying network, timers are needed at some level to trigger retransmissions. 
A host in a distributed system can have several timers outstanding. 
Consider, for example, a server with 200 connections and 3 timers per connection.
Further, as networks scale to gigabit speeds, both the required resolution and the rate at which timers are started and stopped will increase.
Several recent network implementations have been tuned to send packets at a rate of 25000–40000 packets per second.
举个例子，考虑到分布式系统中各个成员间的通信。  
由于在底层网络中消息可能丢失，因此需要某种粒度级别的计时器来触发(消息)重传。一个位于分布式系统下的主机会有几个待完成的计时器。  
举个例子，考虑到一个有200个连接的服务器，其中每个连接对应3个计时器。
此外，随着网络速率达到GB级别，每一个计时器所需的时间粒度和启动、停止的速度要求都会增加。最近的几个网络实现其发送数据包的速率已经被调整为每秒25000-40000了。

#####
Some network implementations (e.g., the BSD TCP implementation) do not use a timer per packet; 
instead, only a few timers are used for the entire networking package.
The BSD TCP implementation gets away with two timers because the TCP implementation maintains its own timers for all outstanding packets, 
and uses a single kernel timer as a clock to run its own timers. 
TCP maintains its packet timers in the simplest fashion: whenever its single kernel timer expires,
it ticks away at all its outstanding packet timers. 
For example, many TCP implementations use two timers: a 200-ms timer and a 500-ms timer.
一些网络实现（例如BSD操作系统的TCP实现）不会为每个数据包都创建对应的计时器；取而代之的是，整个网络包只使用少量的计时器。
BSD的TCP实现只使用了两个计时器，因为tcp实现中为每一个未完成的数据包维护了一个计时器，并且使用单独的一个内核计时器来做为时钟来运行这些计时器。  
TCP以最简单的方式维护数据包的计时器：当单独的内核计时器过期了，便tick推进每一个待完成数据包的计时器。  
举个例子，很多tcp实现使用两个计时器：一个200ms粒度的计时器和一个500ms粒度的计时器。

#####
The naive method works reasonably well if the granularity of timers is low and losses are rare. 
However, it is desirable to improve the resolution of the retransmission timer to allow speedier recovery.
For example, the University of Arizona has a new TCP implementation called TCP Vegas that performs better than the commonly used TCP Reno. 
One of the reasons TCP Reno has bad performance when experiencing losses is the coarse granularity of the timeouts.
如果计时器的粒度比较低且丢包次数很少，则朴素的方法能够比较好的工作。然而，存在希望改进重传计时器粒度的以允许更快恢复(丢包故障)的需求。
举个例子，亚利桑那大学发明的被称作TCP Vegas的新TCP实现其性能就优于常用的TCP Reno实现。
TCP Reno在遇到丢包时性能不佳的原因之一就是控制超时重传的时间粒度太粗。 

#####
Besides faster error recovery, fine granularity timers also allow network protocols to more accurately measure small intervals of time. 
For example, accurate estimates of round trip delay are important for the TCP congestion control algorithm 
and the Scalable Reliable Multicast (SRM) framework that is implemented in the Wb conferencing tool.
Finally, many multimedia applications routinely use timers, and the number of such applications is increasing.
An example can be found in Siemens’ CHANNELS run time system for multimedia 
where each audio stream uses a timer with granularity that lies between 10 and 20 ms. 
For multimedia and other real-time applications, it is important to have worst-case bounds on the processing time to start and stop timers.
除了更快的错误恢复，更细粒度的计时器也允许网络协议能以更小的时间间隔进行更准确地测量。  
举个例子，准确地测量（通信）往返延迟对于TCP拥塞控制算法和基于可拓展的可靠广播框架(SRM)实现的Wb会议工具是很重要的。  
最后，很多多媒体应用通常都使用了计时器，且这些应用的数量正在增加。  
西门子的CHANNELS多媒体运行时系统中可以找到一个案例，其中每个音频流使用一个10到20毫秒粒度的计时器。  
对于多媒体和其它的实时应用程序，对计时器启动和停止处理的耗时下限进行限制是很重要的。  

#####
Besides networking applications, process control 
and other real-time applications will also benefit from large numbers of fine granularity timers.
Also, the number of users on a system may grow large enough to lead to a large number of outstanding timers.
This is the reason cited (for redesigning the timer facility) by the developers of the IBM VM/XA SP1 operating system.
处理网络应用程序，控制处理和其它的实时应用程序也受益于大量细粒度的计时器。  
此外，系统中的用户数量可能会大幅增长而导致同时存在大量待完成的计时器。  
这就是IBM VM/XA SP1操作系统的开发者们提出要重新设计计时器功能的原因。

#####
In the following sections, we will describe a family of schemes for efficient timer implementations 
based on a data structure called a timing wheel.
We will also describe performance results based on a UNIX implementation, 
and survey some of the systems that have implemented timer packages based on the ideas in this paper.
在下面的章节中，我们将讨论一系列基于一种被称作时间轮的数据结构而实现高性能计时器的方案。  
我们还将描述基于UNIX实现的性能成果，同时调查了其它的一些基于本篇博客思路来实现计时器包的系统。  

### II Model(模型)
Our model of a timer module has the following four component routines.
我们的计时器模块的模型包含了4个程序(例程 routines)组件。

#####
**START TIMER (Interval, RequestId, ExpiryAction):**   
The client calls this routine to start a timer that will expire after “Interval” units of time. 
The client supplies a RequestId which is used to distinguish this timer from other timers that the client has outstanding. 
Finally, the client can specify what action must be taken on expiry: 
for instance, calling a client-specified routine, or setting an event flag.
启动计时器(Interval 间隔，RequestId 请求id，ExpiryAction 计时器过期时的要做的操作)：
客户端调用启动计时器的例程，该计时器将在(参数)“间隔”单位时间后到期。  
客户端提供一个请求id用于区分该计时器和客户端其它待完成的计时器。  
最后，客户端可以指定计时器到期时必须执行的操作：例如调用一个客户端指定的例程或者设置一个事件标识。  

#####
**STOP TIMER (RequestId):**
This routine uses its knowledge of the client and RequestId to locate the timer and stop it.
停止计时器(RequestId 请求id)：
这个例程使用客户端和请求id来定位对应的计时器并且停止它。

#####
**PER TICK BOOKKEEPING :**
Let the granularity of the timer be T units. 
Then every units this routine checks whether any outstanding timers have expired; 
if this is the case, it calls STOP TIMER , which in turn calls the next routine.
记录每次时钟滴答：
让计时器的粒度为T个单位。
然后让该例程检查每个单位下是否有待完成的计时器已经过期；如果是这种情况，该例程将调用STOP TIMER，并依次调用下一个例程。

#####
**EXPIRY PROCESSING** : 
This routine does the ExpiryAction specified in the START TIMER call.
这个例程执行START TIMER调用时指定的ExpiryAction操作。

#####
The first two routines are activated on client calls while the last two are invoked on timer ticks.
The timer is often an external hardware clock.
前两个例程在客户端调用时被激活，而后两个则在计时器滴答(ticks)时被调用。  
计时器通常是一个外部的硬件时钟。

#####
The following two performance measures can be used to choose between the various algorithms described in the rest of this paper. 
Both of them are parameterized by , the average(or worst-case) number of outstanding timers.
以下两种性能测试的方法可以被用于在本篇论文剩余部分所描述的一系列算法。
这两种方法都以待完成计时器的平均数量(或者最坏场景下的数量)作为参数。

#####
1. **Space**: The memory required for the data structures used by the timer module
2. **Latency**: The time between the invoking of a routine in the timer module and its completion, 
   assuming that the caller of the routine blocks until the routine completes.
   Both the average and worst case latency are of interest. 

#####
1. 空间：计时器模块所使用数据结构所需的内存
2. 延迟：调用计时器模块例程到其完成的时间间隔，假设例程的调用者将被阻塞直到例程完成。
   其平均延迟和最坏情况下的延迟同样重要。

#####
For example, a client application that implements a transport protocol may find 
that space is cheap and the critical parameters for each routine in the timer module are as shown in Table I.  
举个例子，一个实现了传输协议的客户端程序可以发现其内存开销很低，而且计时器模块中每个例程的关键参数都展示在表I中

#####
The performance measures important for the client applications should be used to choose among timer algorithms.
在选择计时器算法时，性能测试是非常重要的。
![img.png](img.png)

### III. EXISTING TIMER SCHEMES(已经存在的计时器方案)
#####
A. Scheme 1—Straightforward(方案1-直接了当的)