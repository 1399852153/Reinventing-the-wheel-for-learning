# Hashed and Hierarchical Timing Wheels: Efficient Data Structures for Implementing a Timer Facility（多层次的哈希时间轮：实现计时器功能的高效数据结构）
作者：George Varghese and Anthony Lauck

##### 
Abstract— The performance of timer algorithms is crucial to many network protocol implementations that use timers for failure recovery and rate control.  
Conventional algorithms to implement an Operating System timer module take O(n) time to start or maintain a timer, 
where n is the number of outstanding timers: this is expensive for large n.   
This paper shows that by using a circular buffer or timing wheel, it takes O(1) time to start, stop, and maintain timers within the range of the wheel.
摘要- 在很多使用计时器来实现故障恢复和速率控制的网络协议中，计时器算法的性能是非常关键的。
用于实现操作系统计时器模块的常规算法需要花费O(n)的时间复杂度用于启动或者维护一个计时器，n是待完成的计时器对象个数：对于一个很大的n值其开销是巨大的。  
本篇论文展示了通过使用一个环形缓冲器或时间轮，只需要O(1)的时间复杂度便可做到启动、停止和维护一个在当前时间轮范围内的计时器。  

#####
Two extensions for larger values of the interval are described.  
In the first, the timer interval is hashed into a slot on the timing wheel.  
In the second, a hierarchy of timing wheels with different granularities is used to span a greater range of intervals.
The performance of these two schemes and various implementation tradeoffs are discussed.
We have used one of our schemes to replace the current BSD UNIX callout and timer facilities.
Our new implementation can support thousands of outstanding timers without much overhead.
Our timer schemes have also been implemented in other operating systems and network protocol packages.
这里描述了对于支持更大范围区间的两方面拓展。  
首先，计时器的区间被哈希映射到时间轮的一个插槽中。其次，一个具有不同粒度的、具有层次性的时间轮能够拓展支持更大的区间。  
这里讨论了两种方案的性能以及不同实现方式的取舍。  
我们已经使用一种我们的方案来替换当前BSD-UNIX操作系统的UNIX调用和计时器设施。  
我们的新实现可以支持数以千计的待完成的计时器而没有额外的开销。  
我们的计时器实现方案也已经在其它的操作系统和网络协议包中被实现了。  

### I. INTRODUCTION（介绍）
#####
In a centralized or distributed system, we need timers for the following.
在一个中心化的或者分布式的系统中，我们需要以下所展示的计时器。  

#####
Failure Recovery: Several kinds of failures cannot be detected asynchronously.   
Some can be detected by periodic checking (e.g., memory corruption) and such timers always expire.   
Other failures can only be inferred by the lack of some positive action (e.g., message acknowledgment) within a specified period.   
If failures are infrequent, these timers rarely expire.  
故障恢复：少数几种无法被异步检查的故障。其中一些可以被周期性的检查所发现（例如内存损坏memory corruption），并且这些计时器总是会过期。  
其它故障的检测只能通过在一个指定的周期内缺乏某些积极的动作（比如消息确认）来推测。如果故障很少发生，则这些计时器也几乎不会过期

#####
Algorithms in Which the Notion of Time or Relative Time is Integral: 
Examples include algorithms that control the rate of production of some entity (process control, rate-based flow control in communications), 
scheduling algorithms, and algorithms to control packet lifetimes in computer networks.
These timers almost always expire.
关于时间或相对时间的概念是属于积分算法的：
例如包括一些实体生产速率的控制算法（过程控制，通信中基于速度的流量控制），调度算法以及控制计算机网络中数据包存活时间的算法。  
而这些计时器几乎总是会过期的。

#####
The performance of algorithms to implement a timer module becomes an issue when any of the following are true.
* The algorithm is implemented by a processor that is interrupted each time a hardware clock ticks, and the interrupt overhead is substantial.
* Fine granularity timers are required.
* The average number of outstanding timers is large.
当以下任意一项为真时，实现计时器模块的算法就会有性能问题
* 该算法由一个处理器实现，该处理器在每次硬件时钟tick时便被中断，其中断处理的开销是巨大的
* 需要非常细粒度的计时器
* 待完成的计时器平均数量非常大

#####
If the hardware clock interrupts the host every tick, and the interval between ticks is in the order of microseconds, 
then the interrupt overhead is substantial. 
Most host operating systems offer timers of coarse (milliseconds or seconds) granularity.
Alternately, in some systems finer granularity timers reside in special-purpose hardware. 
In either case, the performance of the timer algorithms will be an issue as they determine the latency incurred in starting 
or stopping a timer and the number of timers that can be simultaneously outstanding.
如果每一次硬件时钟tick都会中断主机，且每次tick的间隔在微秒级别，那么中断的开销就会是巨大的。  
大多数的主机操作系统提供的计时器通常是在毫秒或者秒级粒度的。或者，在一些系统中更细粒度的计时器则由专门的硬件实现。  
在任一一种情况下，计时器算法的性能都将是一个问题，因为他们决定了启动或者停止一个计时器的延迟以及可以同一时刻下可维持的待完成计时器的数量。

#####
As an example, consider communications between members of a distributed system. 
Since messages can be lost in the underlying network, timers are needed at some level to trigger retransmissions. 
A host in a distributed system can have several timers outstanding. 
Consider, for example, a server with 200 connections and 3 timers per connection.
Further, as networks scale to gigabit speeds, both the required resolution and the rate at which timers are started and stopped will increase.
Several recent network implementations have been tuned to send packets at a rate of 25000–40000 packets per second.
举个例子，考虑到分布式系统中各个成员间的通信。  
由于在底层网络中消息可能丢失，因此需要某种粒度级别的计时器来触发(消息)重传。一个位于分布式系统下的主机会有几个待完成的计时器。  
举个例子，考虑到一个有200个连接的服务器，其中每个连接对应3个计时器。
此外，随着网络速率达到GB级别，每一个计时器所需的时间粒度和启动、停止的速度要求都会增加。最近的几个网络实现其发送数据包的速率已经被调整为每秒25000-40000了。

#####
Some network implementations (e.g., the BSD TCP implementation) do not use a timer per packet; 
instead, only a few timers are used for the entire networking package.
The BSD TCP implementation gets away with two timers because the TCP implementation maintains its own timers for all outstanding packets, 
and uses a single kernel timer as a clock to run its own timers. 
TCP maintains its packet timers in the simplest fashion: whenever its single kernel timer expires,
it ticks away at all its outstanding packet timers. 
For example, many TCP implementations use two timers: a 200-ms timer and a 500-ms timer.
一些网络实现（例如BSD操作系统的TCP实现）不会为每个数据包都创建对应的计时器；取而代之的是，整个网络包只使用少量的计时器。
BSD的TCP实现只使用了两个计时器，因为tcp实现中为每一个未完成的数据包维护了一个计时器，并且使用单独的一个内核计时器来做为时钟来运行这些计时器。  
TCP以最简单的方式维护数据包的计时器：当单独的内核计时器过期了，便tick推进每一个待完成数据包的计时器。  
举个例子，很多tcp实现使用两个计时器：一个200ms粒度的计时器和一个500ms粒度的计时器。

#####
The naive method works reasonably well if the granularity of timers is low and losses are rare. 
However, it is desirable to improve the resolution of the retransmission timer to allow speedier recovery.
For example, the University of Arizona has a new TCP implementation called TCP Vegas that performs better than the commonly used TCP Reno. 
One of the reasons TCP Reno has bad performance when experiencing losses is the coarse granularity of the timeouts.
如果计时器的粒度比较低且丢包次数很少，则朴素的方法能够比较好的工作。然而，存在希望改进重传计时器粒度的以允许更快恢复(丢包故障)的需求。
举个例子，亚利桑那大学发明的被称作TCP Vegas的新TCP实现其性能就优于常用的TCP Reno实现。
TCP Reno在遇到丢包时性能不佳的原因之一就是控制超时重传的时间粒度太粗。 

#####
Besides faster error recovery, fine granularity timers also allow network protocols to more accurately measure small intervals of time. 
For example, accurate estimates of round trip delay are important for the TCP congestion control algorithm 
and the Scalable Reliable Multicast (SRM) framework that is implemented in the Wb conferencing tool.
Finally, many multimedia applications routinely use timers, and the number of such applications is increasing.
An example can be found in Siemens’ CHANNELS run time system for multimedia 
where each audio stream uses a timer with granularity that lies between 10 and 20 ms. 
For multimedia and other real-time applications, it is important to have worst-case bounds on the processing time to start and stop timers.
除了更快的错误恢复，更细粒度的计时器也允许网络协议能以更小的时间间隔进行更准确地测量。  
举个例子，准确地测量（通信）往返延迟对于TCP拥塞控制算法和基于可拓展的可靠广播框架(SRM)实现的Wb会议工具是很重要的。  
最后，很多多媒体应用通常都使用了计时器，且这些应用的数量正在增加。  
西门子的CHANNELS多媒体运行时系统中可以找到一个案例，其中每个音频流使用一个10到20毫秒粒度的计时器。  
对于多媒体和其它的实时应用程序，对计时器启动和停止处理的耗时下限进行限制是很重要的。  

#####
Besides networking applications, process control 
and other real-time applications will also benefit from large numbers of fine granularity timers.
Also, the number of users on a system may grow large enough to lead to a large number of outstanding timers.
This is the reason cited (for redesigning the timer facility) by the developers of the IBM VM/XA SP1 operating system.
处理网络应用程序，控制处理和其它的实时应用程序也受益于大量细粒度的计时器。  
此外，系统中的用户数量可能会大幅增长而导致同时存在大量待完成的计时器。  
这就是IBM VM/XA SP1操作系统的开发者们提出要重新设计计时器功能的原因。

#####
In the following sections, we will describe a family of schemes for efficient timer implementations 
based on a data structure called a timing wheel.
We will also describe performance results based on a UNIX implementation, 
and survey some of the systems that have implemented timer packages based on the ideas in this paper.
在下面的章节中，我们将讨论一系列基于一种被称作时间轮的数据结构而实现高性能计时器的方案。  
我们还将描述基于UNIX实现的性能成果，同时调查了其它的一些基于本篇博客思路来实现计时器包的系统。  

### II Model(模型)
Our model of a timer module has the following four component routines.
我们的计时器模块的模型包含了4个程序(例程 routines)组件。

#####
**START TIMER (Interval, RequestId, ExpiryAction):**   
The client calls this routine to start a timer that will expire after “Interval” units of time. 
The client supplies a RequestId which is used to distinguish this timer from other timers that the client has outstanding. 
Finally, the client can specify what action must be taken on expiry: 
for instance, calling a client-specified routine, or setting an event flag.
启动计时器(Interval 间隔，RequestId 请求id，ExpiryAction 计时器过期时的要做的操作)：
客户端调用启动计时器的例程，该计时器将在(参数)“间隔”单位时间后到期。  
客户端提供一个请求id用于区分该计时器和客户端其它待完成的计时器。  
最后，客户端可以指定计时器到期时必须执行的操作：例如调用一个客户端指定的例程或者设置一个事件标识。  

#####
**STOP TIMER (RequestId):**
This routine uses its knowledge of the client and RequestId to locate the timer and stop it.
停止计时器(RequestId 请求id)：
这个例程使用客户端和请求id来定位对应的计时器并且停止它。

#####
**PER TICK BOOKKEEPING :**
Let the granularity of the timer be T units. 
Then every units this routine checks whether any outstanding timers have expired; 
if this is the case, it calls STOP TIMER , which in turn calls the next routine.
记录每次时钟滴答：
让计时器的粒度为T个单位。
然后让该例程检查每个单位下是否有待完成的计时器已经过期；如果是这种情况，该例程将调用STOP TIMER，并依次调用下一个例程。

#####
**EXPIRY PROCESSING** : 
This routine does the ExpiryAction specified in the START TIMER call.
这个例程执行START TIMER调用时指定的ExpiryAction操作。

#####
The first two routines are activated on client calls while the last two are invoked on timer ticks.
The timer is often an external hardware clock.
前两个例程在客户端调用时被激活，而后两个则在计时器滴答(ticks)时被调用。  
计时器通常是一个外部的硬件时钟。

#####
The following two performance measures can be used to choose between the various algorithms described in the rest of this paper. 
Both of them are parameterized by , the average(or worst-case) number of outstanding timers.
以下两种性能测试的方法可以被用于在本篇论文剩余部分所描述的一系列算法。
这两种方法都以待完成计时器的平均数量(或者最坏场景下的数量)作为参数。

#####
1. **Space**: The memory required for the data structures used by the timer module
2. **Latency**: The time between the invoking of a routine in the timer module and its completion, 
   assuming that the caller of the routine blocks until the routine completes.
   Both the average and worst case latency are of interest. 

#####
1. 空间：计时器模块所使用数据结构所需的内存
2. 延迟：调用计时器模块例程到其完成的时间间隔，假设例程的调用者将被阻塞直到例程完成。
   其平均延迟和最坏情况下的延迟同样重要。

#####
For example, a client application that implements a transport protocol may find 
that space is cheap and the critical parameters for each routine in the timer module are as shown in Table I.  
举个例子，一个实现了传输协议的客户端程序可以发现其内存开销很低，而且计时器模块中每个例程的关键参数都展示在表I中

#####
The performance measures important for the client applications should be used to choose among timer algorithms.
在选择计时器算法时，性能测试是非常重要的。
![img.png](img.png)

### III. EXISTING TIMER SCHEMES(已经存在的计时器方案)
#####
A. Scheme 1—Straightforward(方案1-直接了当的)
#####
Here START TIMER finds a memory location and sets that location to the specified timer interval. 
Every units, PER TICK BOOKKEEPING will decrement each outstanding timer;
if any timer becomes zero, EXPIRY PROCESSING is called.
START TIMER找到一块内存并且设置特定的计时器时间间隔。
每一个单位时间，PER TICK BOOKKEEPING将会减少每一个待完成计时器的值，如果任一计时器被减为0，则调用EXPIRY PROCESSING。

#####
This scheme is extremely fast except for per tick bookkeeping. 
It also uses one record per outstanding timer, the minimum space possible. 
Its performance is summarized in Table II. It is appropriate if:
* there are only a few outstanding timers;
* most timers are stopped within a few ticks of the clock;
* PER TICK BOOKKEEPING is done with suitable performance by special-purpose hardware.

除了每次tick时都需要记录之外，这个方案非常的快。  
它也为每一个待完成的计时器都使用一个记录，空间开销也可能是最小的。
表II总结了其性能: 如果满足以下条件该方案将是合适的：
* 只有少数的几个待完成的计时器
* 绝大多数计时器会在少数的几个tick内停止(完成)
* 通过专门的硬件以合理的性能完成PER TICK BOOKKEEPING

#####
Note that instead of doing a Decrement, we can store the absolute time at which timers expire and do a Compare.
This option is valid for all timer schemes we describe; 
the choice between them will depend on the size of the time-of-day field,
the cost of each instruction, and the hardware on the machine implementing these algorithms.
In this paper we will use the Decrement option, except when describing Scheme 2.
请注意，我们可以存储计时器的绝对过期时间来(与当前时间)进行比较来代替递减。
这个选项适用于我们所描述的所有计时器方案；
两种选项如何选择取决于时间字段的大小，每条指令的成本以及实现这些算法的机器硬件。
在本文中，除了方案2，我们都将使用递减的选项。

#####
B. Scheme 2—Ordered List(方案2-有序列表)
Here PER TICK BOOKKEEPING latency is reduced at the expense of START TIMER performance. 
Timers are stored in an ordered list. 
Unlike Scheme 1, we will store the absolute time at which the timer expires, and not the interval before expiry.
该方案中，PER TICK BOOKKEEPING的延迟降低是以START TIMER的性能为代价的。  
计时器被存储在一个有序列表中。
与方案1不同，我们将存储计时器过期的绝对时间，而不是过期前的间隔。

![img_1.png](img_1.png)

#####
The timer that is due to expire at the earliest time is stored at the head of the list. 
Subsequent timers are stored in increasing order as shown in Fig. 1
最早到期的计时器被存储再列表的头部。
后续的计时器以到期时间升序排序存储在列表中，如图1所示。

#####
In Fig. 1, the lowest timer is due to expire at absolute time 10 h, 23 min, and 12 s.
在图1中，最小的计时器将在绝对时间10小时，23分钟，12秒时过期。

#####
Because the list is sorted, PER TICK BOOKKEEPING need only increment the current time of day, and compare it with the head of the list. 
If they are equal, or the time of day is greater, it deletes that list element and calls EXPIRY PROCESSING . 
It continues to delete elements at the head of the list until the expiry time of the head of the list is strictly less than the time of day.
由于列表是有序的，PER TICK BOOKKEEPING只需要增加当前的时间，并且用其与列表头部的计时器进行比较。  
如果他们相等，或者当前时间更大，则删除列表中的元素并且调用EXPIRY PROCESSING。  
其继续删除列表头部的元素(并调用EXPIRY PROCESSING)，直到列表头部元素的过期时间严格的小于当前时间。  

#####
START TIMER searches the list to find the position to insert the new timer.
In the example, START TIMER will insert a new timer due to expire at 10:24:01 between the second and third elements.
START TIMER对列表进行搜索以找到新计时器插入的位置。
在本例中，START TIMER将一个过期时间为10:24:01的新计时器，插入到第二个和第三个元素之间。

#####
The worst-case latency to start a timer is O(n). 
The average latency depends on the distribution of timer intervals (from time started to time stopped), 
and the distribution of the arrival process according to which calls to START TIMER are made.
启动一个计时器的延迟在最坏情况下为O(n)。
平均的延迟取决于计时器间隔的分布(从开始时间到停止时间)，以及根据调用START TIMER所依据的到达过程的分布。
（todo 好抽象，没翻译好。。。）

#####
Interestingly, this can be modeled (Fig. 2) as a single queue with infinite servers; 
this is valid because every timer in the queue is essentially decremented (or served) every timer tick.
It is shown in, that we can use Little’s result to obtain the average number in the queue; 
also the distribution of the remaining time of elements in the timer queue seen by a new request is the residual life density 
of the timer interval distribution.
有趣的是，这些可以被建模为一个有着无限服务器的单条队列，
这是可行的，因为队列中的每一个计时器本质上都会在每一个计时器tick中递减(或提供服务)。  
如展示的那样，我们可以使用Little的结果来获得队列中的平均数；也能由一个新请求中计时器剩余寿命的密度间隔分布看到在计时器队列中元素的剩余时间分布。
（抽象。。。）

#####
If the arrival distribution is Poisson, the list is searched from the head, and reads and writes both cost one unit, 
then the average cost of insertion for negative exponential and uniform timer interval distributions is shown into be
如果到达的分布符合泊松分布，从列表头部的搜索以及读取和写入都花费一个单位，  
则负指数分布下的平均插入耗时和均匀的计时器间隔分布如下所示：

![img_2.png](img_2.png)

#####
Results for other timer interval distributions can be computed using a result in. 
For a negative exponential distribution we can reduce the average cost to 2+n/3 by searching the list from the rear. 
In fact, if timers are always inserted at the rear of the list, this search strategy yields an O(1) START TIMER latency. 
This happens, for instance, if all timers intervals have the same value. 
However, for a general distribution of the timer interval, we assume the average latency of insertion is O(n).
其它计时器间隔的分布的结果可以被用来计算该结果。  
对于负指数的分布，通过从后面搜索列表我们可以将平均耗时减少到2+n/3。
事实上，如果计时器总是被插入在列表后端，START TIMER在该搜索策略下会产生O(1)的延迟。  
例如，如果所有的计时器都具有相同的时间间隔。
然而，对于一个常规的计时器间隔分布，我们假设平均的插入延迟为O(n)。

![img_3.png](img_3.png)

#####
STOP TIMER need not search the list if the list is doubly linked. 
When START TIMER inserts a timer into the ordered list, it can store a pointer to the element. 
STOP TIMER can then use this pointer to delete the element in O(1) time from the doubly linked list. 
This can be used by any timer scheme.
如果链表是双向链表，则STOP TIMER将不需要进行搜索。
当START TIMER项有序列表插入一个计时器时，它可以存储该元素的一个指针。
STOP TIMER可以使用这个指针以O(1)的时间复杂度从双向链表中删除该元素。
这(个技巧)可以被任何计时器(实现)方案所使用。

#####
If Scheme 2 is implemented by a host processor, the interrupt overhead on every tick can be avoided 
if there is hardware support to maintain a single timer. 
The hardware timer is set to expire at the time at which the timer at the head of the list is due to expire. 
The hardware intercepts all clock ticks and interrupts the host only when a timer actually expires.
Unfortunately, some processor architectures do not offer this capability.
Algorithms similar to Scheme 2 are used by both VMS and UNIX in implementing their timer modules. 
The performance of the two schemes is summarized in Table II.
如果方案2是由主机处理器实现的，那么如果有硬件来支持和维护一个单独的计时器则可以避免每一次tick时的中断开销。  
硬件计时器被设置为在列表头部的计时器过期时，到期。
硬件拦截所有的时钟tick并且只在计时器到期时中断主机。
不幸的是，一些处理器架构并没有提供这一功能。
VMS和UNIX操作系统在实现他们的计时器模块时都使用了类似方案2的算法。
表II总结了这两种方案的性能。

#####
As for Space, Scheme 1 needs the minimum space possible;
Scheme 2 needs extra space for the forward and back pointers between queue elements.  
对于空间使用上，方案1所需要的空间尽可能的少；方案2则需要额外的空间用于(维护)队列元素之间的前向、后向指针。

#####
IV. SORTING TECHNIQUES AND TIME-FLOW MECHANISMS（排序技术和时间流机制）
**A. Sorting Algorithms and Priority Queues（排序算法和优先级队列）**
#####
Scheme 2 reduced PER TICK BOOKKEEPING latency at the expense of START TIMER by keeping the timer list sorted.
Consider the relationship between timer and sorting algorithms depicted in Fig. 3. However, consider the following.  
方案2通过保持计时器列表的有序性，以START TIMER为代价(注：START TIMER更加耗时了，因为需要有序)来减少PER TICK BOOKKEEPING的延迟。  
考虑到图3中计时器和排序算法之间的关系。然而考虑以下情况。

#####
*  In a typical sort, all elements are input to the module when the sort begins;the sort ends by outputting all elements in sorted order.
   A timer module performs a more dynamic sort because elements arrive at different times and are output at different times.
*  In a timer module, the elements to be “sorted” change their value over time if we store the interval. 
   This is not true if we store the absolute time of expiry.  

*  在典型的排序中，当排序开始时所有的元素作为模块的输入；排序结束时按照排序的顺序输出所有的元素。
   计时器模块使用一种更加动态的排序，因为元素是在不同时间点到来的并且其也在不同的时间点被输出。
*  在计时器模块中，如果我们存储(时间)间隔,则要被排序的元素会随着时间而改变它们的值。
   如果我们存储了(计时器)过期的绝对时间，则没这个问题。

#####
A data structure that allows “dynamic” sorting is a priority queue. 
A priority queue allows elements to be inserted and deleted; it also allows the smallest element in the set to be found. 
A timer module can use a priority queue, and do PER TICK BOOKKEEPING only on the smallest timer element.  
一种允许动态排序的数据结构就是优先级队列。
一个优先级队列允许元素被插入和删除；也允许找到集合中最小的元素。
一个计时器模块可以使用优先级队列，并且只在最小的计时器元素上执行PER TICK BOOKKEEPING。

#####
* Scheme 3—Tree-Based Algorithms: A linked list(Scheme 2) is one way of implementing a priority queue. For large n, tree-based data structures are better. 
  These include unbalanced binary trees, heaps, post-order and end-order trees, and leftist-trees. 
  They attempt to reduce the latency in Scheme 2 for START TIMER from to O(n) to O(log n).
  In it is reported that this difference is significant for large , and that unbalanced binary trees are less expensive than balanced binary trees. 
  Unfortunately, unbalanced binary trees easily degenerate into a linear list; this can happen, for instance, if a set of equal timer intervals are inserted.  

* 方案3-基于树的算法：链表(方案2)是一种实现优先级队列的方案。当n值很大时，基于树的数据结构会更优秀。
  这其中包括了非平衡二叉树，堆，后序树和末序树，以及左树。
  它们试图将方案2中START TIMER的延迟从O(n)减少到O(log n)。
  据说在大规模（元素存储）时差异是显著的，并且非平衡的二叉树的开销要低于自平衡二叉树。
  不幸的是，非平衡的二叉树很容易退化为线性表；例如，如果插入一组相同时间间隔的计时器时就会发生这种情况。
#####
We will lump these algorithms together as Scheme 3:tree-based algorithms. 
The performance of Scheme 3 is summarized in Table II.  
我们将这些算法汇总为方案3：基于树的算法。
表II中总结了方案3的性能。
