# Hashed and Hierarchical Timing Wheels: Efficient Data Structures for Implementing a Timer Facility（多层次的哈希时间轮：实现计时器功能的高效数据结构）
作者：George Varghese and Anthony Lauck

##### 
Abstract— The performance of timer algorithms is crucial to many network protocol implementations that use timers for failure recovery and rate control.  
Conventional algorithms to implement an Operating System timer module take O(n) time to start or maintain a timer, 
where n is the number of outstanding timers: this is expensive for large n.   
This paper shows that by using a circular buffer or timing wheel, it takes O(1) time to start, stop, and maintain timers within the range of the wheel.
摘要- 在很多使用计时器来实现故障恢复和速率控制的网络协议中，计时器算法的性能是非常关键的。
用于实现操作系统计时器模块的常规算法需要花费O(n)的时间复杂度用于启动或者维护一个计时器，n是待完成的计时器对象个数：对于一个很大的n值其开销是巨大的。  
本篇论文展示了通过使用一个环形缓冲器或时间轮，只需要O(1)的时间复杂度便可做到启动、停止和维护一个在当前时间轮范围内的计时器。  

#####
Two extensions for larger values of the interval are described.  
In the first, the timer interval is hashed into a slot on the timing wheel.  
In the second, a hierarchy of timing wheels with different granularities is used to span a greater range of intervals.
The performance of these two schemes and various implementation tradeoffs are discussed.
We have used one of our schemes to replace the current BSD UNIX callout and timer facilities.
Our new implementation can support thousands of outstanding timers without much overhead.
Our timer schemes have also been implemented in other operating systems and network protocol packages.
这里描述了对于支持更大范围区间的两方面拓展。  
首先，计时器的区间被哈希映射到时间轮的一个插槽中。其次，一个具有不同粒度的、具有层次性的时间轮能够拓展支持更大的区间。  
这里讨论了两种方案的性能以及不同实现方式的取舍。  
我们已经使用一种我们的方案来替换当前BSD-UNIX操作系统的UNIX调用和计时器设施。  
我们的新实现可以支持数以千计的待完成的计时器而没有额外的开销。  
我们的计时器实现方案也已经在其它的操作系统和网络协议包中被实现了。  

### I. INTRODUCTION（介绍）
#####
In a centralized or distributed system, we need timers for the following.
在一个中心化的或者分布式的系统中，我们需要以下所展示的计时器。  

#####
Failure Recovery: Several kinds of failures cannot be detected asynchronously.   
Some can be detected by periodic checking (e.g., memory corruption) and such timers always expire.   
Other failures can only be inferred by the lack of some positive action (e.g., message acknowledgment) within a specified period.   
If failures are infrequent, these timers rarely expire.  
故障恢复：少数几种无法被异步检查的故障。其中一些可以被周期性的检查所发现（例如内存损坏memory corruption），并且这些计时器总是会过期。  
其它故障的检测只能通过在一个指定的周期内缺乏某些积极的动作（比如消息确认）来推测。如果故障很少发生，则这些计时器也几乎不会过期

#####
Algorithms in Which the Notion of Time or Relative Time is Integral: 
Examples include algorithms that control the rate of production of some entity (process control, rate-based flow control in communications), 
scheduling algorithms, and algorithms to control packet lifetimes in computer networks.
These timers almost always expire.
关于时间或相对时间的概念是属于积分算法的：
例如包括一些实体生产速率的控制算法（过程控制，通信中基于速度的流量控制），调度算法以及控制计算机网络中数据包存活时间的算法。  
而这些计时器几乎总是会过期的。

#####
The performance of algorithms to implement a timer module becomes an issue when any of the following are true.
* The algorithm is implemented by a processor that is interrupted each time a hardware clock ticks, and the interrupt overhead is substantial.
* Fine granularity timers are required.
* The average number of outstanding timers is large.
当以下任意一项为真时，实现计时器模块的算法就会有性能问题
* 该算法由一个处理器实现，该处理器在每次硬件时钟tick时便被中断，其中断处理的开销是巨大的
* 需要非常细粒度的计时器
* 待完成的计时器平均数量非常大

#####
If the hardware clock interrupts the host every tick, and the interval between ticks is in the order of microseconds, 
then the interrupt overhead is substantial. 
Most host operating systems offer timers of coarse (milliseconds or seconds) granularity.
Alternately, in some systems finer granularity timers reside in special-purpose hardware. 
In either case, the performance of the timer algorithms will be an issue as they determine the latency incurred in starting 
or stopping a timer and the number of timers that can be simultaneously outstanding.
如果每一次硬件时钟tick都会中断主机，且每次tick的间隔在微秒级别，那么中断的开销就会是巨大的。  
大多数的主机操作系统提供的计时器通常是在毫秒或者秒级粒度的。或者，在一些系统中更细粒度的计时器则由专门的硬件实现。  
在任一一种情况下，计时器算法的性能都将是一个问题，因为他们决定了启动或者停止一个计时器的延迟以及可以同一时刻下可维持的待完成计时器的数量。

#####
As an example, consider communications between members of a distributed system. 
Since messages can be lost in the underlying network, timers are needed at some level to trigger retransmissions. 
A host in a distributed system can have several timers outstanding. 
Consider, for example, a server with 200 connections and 3 timers per connection.
Further, as networks scale to gigabit speeds, both the required resolution and the rate at which timers are started and stopped will increase.
Several recent network implementations have been tuned to send packets at a rate of 25000–40000 packets per second.
举个例子，考虑到分布式系统中各个成员间的通信。  
由于在底层网络中消息可能丢失，因此需要某种粒度级别的计时器来触发(消息)重传。一个位于分布式系统下的主机会有几个待完成的计时器。  
举个例子，考虑到一个有200个连接的服务器，其中每个连接对应3个计时器。
此外，随着网络速率达到GB级别，每一个计时器所需的时间粒度和启动、停止的速度要求都会增加。最近的几个网络实现其发送数据包的速率已经被调整为每秒25000-40000了。

#####
Some network implementations (e.g., the BSD TCP implementation) do not use a timer per packet; 
instead, only a few timers are used for the entire networking package.
The BSD TCP implementation gets away with two timers because the TCP implementation maintains its own timers for all outstanding packets, 
and uses a single kernel timer as a clock to run its own timers. 
TCP maintains its packet timers in the simplest fashion: whenever its single kernel timer expires,
it ticks away at all its outstanding packet timers. 
For example, many TCP implementations use two timers: a 200-ms timer and a 500-ms timer.
一些网络实现（例如BSD操作系统的TCP实现）不会为每个数据包都创建对应的计时器；取而代之的是，整个网络包只使用少量的计时器。
BSD的TCP实现只使用了两个计时器，因为tcp实现中为每一个未完成的数据包维护了一个计时器，并且使用单独的一个内核计时器来做为时钟来运行这些计时器。  
TCP以最简单的方式维护数据包的计时器：当单独的内核计时器过期了，便tick推进每一个待完成数据包的计时器。  
举个例子，很多tcp实现使用两个计时器：一个200ms粒度的计时器和一个500ms粒度的计时器。

#####
The naive method works reasonably well if the granularity of timers is low and losses are rare. 
However, it is desirable to improve the resolution of the retransmission timer to allow speedier recovery.
For example, the University of Arizona has a new TCP implementation called TCP Vegas that performs better than the commonly used TCP Reno. 
One of the reasons TCP Reno has bad performance when experiencing losses is the coarse granularity of the timeouts.
如果计时器的粒度比较低且丢包次数很少，则朴素的方法能够比较好的工作。然而，存在希望改进重传计时器粒度的以允许更快恢复(丢包故障)的需求。
举个例子，亚利桑那大学发明的被称作TCP Vegas的新TCP实现其性能就优于常用的TCP Reno实现。
TCP Reno在遇到丢包时性能不佳的原因之一就是控制超时重传的时间粒度太粗。 